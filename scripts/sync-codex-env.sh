#!/bin/bash
# =============================================================================
# Codex environment.toml 生成スクリプト
#
# このPC上のローカル .env ファイル（backend/.env, frontend/.env.local）を
# ソースとして読み取り、.codex/environments/environment.toml の [env] セクション
# を生成します。
#
# ⚠️  このスクリプトは .env が実際に存在するメインのローカルディレクトリで
#     実行してください。worktree には .env がないため動きません。
#
# 使い方:
#   ./scripts/sync-codex-env.sh                  # 自身の environment.toml を更新
#   ./scripts/sync-codex-env.sh /path/to/worktree # 別 worktree の environment.toml を更新
# =============================================================================

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
SOURCE_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# 引数があれば、書き出し先の worktree パスとして使う
TARGET_ROOT="${1:-$SOURCE_ROOT}"

BACKEND_ENV="$SOURCE_ROOT/backend/.env"
FRONTEND_ENV="$SOURCE_ROOT/frontend/.env.local"
TOML_DIR="$TARGET_ROOT/.codex/environments"
TOML_FILE="$TOML_DIR/environment.toml"

echo "🐻 クマ検出警報システム - Codex 環境変数同期"
echo ""
echo "   読み取り元: $SOURCE_ROOT"
echo "   書き出し先: $TARGET_ROOT"
echo ""

# =============================================================================
# 1. ソースの .env ファイルが存在するか確認
# =============================================================================
missing=false

if [ ! -f "$BACKEND_ENV" ]; then
    echo "❌ $BACKEND_ENV が見つかりません"
    missing=true
fi

if [ ! -f "$FRONTEND_ENV" ]; then
    echo "❌ $FRONTEND_ENV が見つかりません"
    missing=true
fi

if [ "$missing" = true ]; then
    echo ""
    echo "このスクリプトは .env ファイルが存在するローカルディレクトリで実行してください。"
    exit 1
fi

echo "📖 読み取り: backend/.env"
echo "📖 読み取り: frontend/.env.local"

# =============================================================================
# 2. .codex/environments/environment.toml を準備
# =============================================================================
mkdir -p "$TOML_DIR"

if [ ! -f "$TOML_FILE" ]; then
    cat > "$TOML_FILE" << 'TOML_HEADER'
# THIS IS AUTOGENERATED. DO NOT EDIT MANUALLY
version = 1
name = "hack1_bear"

[setup]
script = ""
TOML_HEADER
    echo "📄 environment.toml を新規作成しました"
fi

# =============================================================================
# 3. .env をパースして [env] セクションを生成
# =============================================================================
parse_env_file() {
    local file="$1"
    local label="$2"
    echo ""
    echo "# --- $label ---"
    while IFS= read -r line || [ -n "$line" ]; do
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            value="${value//\"/\\\"}"
            echo "$key = \"$value\""
        fi
    done < "$file"
}

env_block="[env]"
env_block+="$(parse_env_file "$BACKEND_ENV" "backend/.env")"
env_block+="$(parse_env_file "$FRONTEND_ENV" "frontend/.env.local")"

# =============================================================================
# 4. 既存の [env] を置換して書き出し
# =============================================================================
tmp_file=$(mktemp)

awk '
    /^\[env\]/ { in_env=1; next }
    in_env && /^\[/ { in_env=0 }
    !in_env { print }
' "$TOML_FILE" > "$tmp_file"

# 末尾の空行を整理
sed -i '' -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$tmp_file" 2>/dev/null || \
    sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$tmp_file" 2>/dev/null || true

printf '\n%s\n' "$env_block" >> "$tmp_file"
mv "$tmp_file" "$TOML_FILE"

# =============================================================================
# 完了
# =============================================================================
echo ""
echo "✅ environment.toml に [env] セクションを同期しました"
echo ""
echo "   反映された環境変数:"
echo "$env_block" | grep '=' | sed 's/ *=.*//' | sed 's/^/     /'
echo ""
echo "🎉 完了！"
